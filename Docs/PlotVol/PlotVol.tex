\documentclass[12pt]{article}
\setlength{\textheight}{9.80in}
\setlength{\textwidth}{6.40in}
\setlength{\oddsidemargin}{0.0mm}
\setlength{\evensidemargin}{1.0mm}
\setlength{\topmargin}{-0.6in}
\setlength{\parindent}{0.2in}
\setlength{\parskip}{1.5ex}
\newtheorem{defn}{Definition}
%\renewcommand{\baselinestretch}{2}

\begin{document}

\thispagestyle{empty}

\title{A Description of {\it PlotVol}}


\author{C. Godsalve \\
F2 Swainstone Road \\
Reading\\
RG2 ODX \\
United Kingdom\\
Tel: (0118) 9864389}


\date{email:{\tt seagods@hotmail.com}}


\maketitle
\tableofcontents


\section{The Problem}

In the {\it PlotSurf} routine, we had a function $F(x,y)$ defined at a set
of nodes in the $(x,y)$ plane. These points had a triangulation. The
triangulation could have been defined on a regular grid, or it may have
been a Delaunay triangulation on a set of arbitrary points.

We then mapped the triangulation in the two dimensional plane to
a two dimensional surface embedded in a three dimensional space.
That is we mapped $(x_i, y_i) \rightarrow (x_i,y_i,z_i)$ where
 $z_i=F(x_i, y_i)$. As an alternative, we could have used {\it PlotCont},
 where we do not map the triangulation into a three dimensional space, 
 but use contours instead. Of course we view the two dimensional 
contour map from a point outside the two dimensional plane.

The {\it PlotVol} routine faces a similar problem. We have a function
defined at a set of nodes $(x_i,y_i,z_i)$. Instead of  a two
dimensional region
being decomposed into triangles, we have a three dimensional region
decomposed into tetrahedra. It may be a regular mesh such as is given by 
$basicCube$, or it may be  an irregular mesh generated by a three
dimensional Delaunay "triangulation".

We cannot do the same "trick" as we did in {\it PlotSurf}, as we cannot view the three
dimensional "surface" embedded in four dimensions. So, we must use
the same technique as in {\it PlotCont}. Instead of a set of one dimensional
 contours embedded in a two dimensional space, we shall have two dimensional
 isosurface "contours" embedded in a three dimensional space.

There are differences between these two dimensional contours and 
the one dimensional contours of {\it PlotCont}. First, we cannot view
the contours from "outside" as we can with the contours of a function
of two variables. This means that we must use transparency and lighting
to visualise the contours. An immediate consequence is that the
surfaces will have to be oriented. (We simply ignore the possibility
of a non-orientable surface such as a Klein Bottle.)  

Now, orientation is a global property. If we have a function
 $W=W(x,y,z)$, and a set of contour levels $W_c$ we can 
find the intersection of $W=W_c$ with a tetrahedron via linear
interpolation of the function values at the nodes. This will
either be a triangle where the surface "cuts off" one of the corners of a tetrahedron,
or a quadrilateral where the surface separates two edges.
However, this gives us no information whatsoever about the global
 orientation. All we can do is ensure that neighbouring facets of
the isosurface have the same orientation as given by surface 
normal of the facets. We may change the
orientation of all the facets of a given isosurface later. What we cannot
have is an isosurface where neigbours have opposite surface normals.
This will mess up the lighting which we need to visualise the surface with.

A simple example would be (an approximation) of a sphere made up of triangular facets.
Here we might end up with all the surface normals pointing outward, or
all pointing inwards.  
 For lighting, we would want them all pointing outwards.
All we have to do to swap is calculate the surface normals 
as ${\bf b} \times {\bf a}$
instead of ${\bf a} \times {\bf b}$.

So, what strategy is needed to ensure that the isosurface has a global
orientation? We shall use the following method. Given a $W_c$, we visit
each tetrahedron in turn, until we find one which intersects the
surface $W=W_c$. We assign an arbitrary orientation, and call
a function called $SurfGrow$,  passing it the identity of the
cut tetrahedron. On a first call, the first facet
of the surface is found. Then $SurfGrow$ will call itself with 
the identity of the  neighbouring tetrahedra, and so on, ensuring the intersecting facets
in the neighbours have the same orientation as facet in the tetrahedron
that calls $SurfGrow$. In this way, we grow the surface while maintaining 
a global orientation. We shall now go into detail as to how this
is done later.

\section{The Tetrahedron}
In Fig.1, we depict a tetrahedron. We have nodes (connection points), numbered one to four. Node
1 shall be the origin of a local coordinate system. The
vector $\vec{12}$ from node 1 to node 2 shall be labeled $\bf a$. The vector
$\vec{13}$ shall be $\bf b$, and the vector $\vec{14}$
shall be $\bf c$. The three edge  vectors $\bf e_1$, $\bf e_2$, and $\bf e_3$
shall correspond to $\bf a$, $\bf b$, and $\bf c$. Edges $\bf e_4$,
 $\bf e_5$, and $\bf e_6$, 
are $\vec{23}$, $\vec{24}$, and $\vec{34}$.
The faces 1 to 4 are numbered so that face 1 does not contain node 1,
 face 2 does not contain node 2, and so on.
\begin{figure}
\vspace*{14cm}
% scaling factor of 1 for dvips is 100, for dvi2ps it is 1.0
\special{psfile=Tet.eps hscale=80 vscale=80 hoffset=0 voffset=100}
\caption{The node, edge, and face numbers for the tetrahedron}
\end{figure}

We assume that our tetrahedral mesh is such that ${\bf a} \cdot ( 
{\bf b} \times {\bf c})$ is always positive. Further, we encode
the following information. Each tetrahedron shall store the tetrahedron
numbers of the neighbours on faces 1 to 4, and it shall also store
the face numbers that a point crossing its face would arrive at.
For instance, if we have a point on face 1 of the current tetrahedron, this
point might be on face 3 of the neighbour on face 1. 

An isosurface can intersect a tetrahedron in different ways. For
the present we ignore the possibility that the isosurface  passes
through the tetrahedron nodes. Now, we shall look at edges 1 to 6
in the order depicted in Fig.1. We shall have either three cut
edges or four. Our isosurfaces shall consist of (mostly triangular) facets,
 the facets shall have 3 or for corners referred to as nodes $t$ which
are not nodes in the tetrahedral mesh. We call the nodes
 that cut the tetrahedron  $t_1$, $t_2$, $t_3$, and  $t_4$ if there
is a cut on a fourth edge.

For the moment, we assume that we arrive in the $SurfGrow$ function
from the main function, that is to say, it is a first call before
any recursion begins. We have a Boolean matrix  $Done[itet][idmax]$.
This is set false for each tetrahedron. Just as with a contour map,
 we may have more than one contour for each contour level. At the
moment we allow for a maximum number of isosurfaces per level
to be $idmax$.

\begin{figure}
\vspace*{14cm}
% scaling factor of 1 for dvips is 100, for dvi2ps it is 1.0
\special{psfile=Corners.eps hscale=80 vscale=80 hoffset=0 voffset=100}
\caption{Triangle numbering for the possibilities of cut off nodes}
\end{figure}

In Fig.2, we see the possibilities where there are only three
cut edges. As we visit the edges 1 to 6 in order, then $t_1$, $t_2$, and $t_3$
are the last three new nodes (in order). On inspection, we
soon  arrive at table 1. Because we don't know the orientation
of the surface, we do not insist that the three triangle nodes 
must be clockwise or anticlockwise whether viewed from the  inside or the outside
of the tetrahedron.  Reading the first three  lines of the tetrahedron,
we see that if tetrahedron node 1 is cut off, there are cuts 
on faces 2, 3, and 4. Each of these cut faces are cut by a line segment
between nodes $t_a$ and $t_b$.
So that face 2 is cut by new triangle nodes $t_2$ and $t_3$, Face
3 is cut by nodes  $t_3$ and $t_1$, and face 4 is cut by (new)  nodes $t_1$ and $t_2$.
It's not much of a table as the third and fourth column's
repeat for every "cut off" node.

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|}\hline
Node &    Face   &  $t_a$ &  $t_b$   \\ \hline
1 &        2  &   2   &  3    \\ \hline
1 &        3  &   3   &  1    \\ \hline
1 &        4  &   1   &  2    \\ \hline
2 &        1  &   2   &  3    \\ \hline
2 &        3  &   3   &  1    \\ \hline
2 &        4  &   1   &  2    \\ \hline
3 &        1  &   2   &  3    \\ \hline
3 &        2  &   3   &  1    \\ \hline
3 &        4  &   1   &  2    \\ \hline
4 &        1  &   2   &  3    \\ \hline
4 &        2  &   3   &  1    \\ \hline
4 &        3  &   1   &  2    \\ \hline
\end{tabular}
\end{center}
\caption{The faces cut by nodes $t_1$, $t_2$, and $t_3$ if the
node in the first column is "cut off" by the isosurface.}
\end{table}

So, if we have three cuts we must call $SurfGrow(in,t_a,t_b,if,W_c, ix1, ix2, iy1, iy2)$
three times for the neighbours $in$ on three cut faces, with (cut edge) triangle
node numbers $t_a$ and $t_b$. When it arrives in $SurfGrow$ on this recursive
call, $in$ tells $SurfGrow$ which tetrahedron it is in,
 and that the calling tetrahedron is on face $if$ of the current
tetrahedron. The number $W_c$ is the contour level, and the last four integers
tell it what tetrahedron nodes the cuts lie between.

Before looking at what happens in the recursive call, we consider the
possibility of four cut nodes in a first call to $SurfGrow$. This happens
when the isosurface separates two edges. The possibilities are depicted
 in Figs.3, 4, and 5. We note that the linear interpolation simplifies
things a great deal in that we can have only one line segment and two
edge cuts on a facet. If we had four edge cuts in total, but
the specified  edge pairs were not separated, this would imply
three edge cuts on the same facet:
 this is not possible. If we have cuts on edge 1 (node 1 - node 2) and 
edge 2 (node 1 - node 3) of a tetrahedron
facet, then this implies that either nodes 2 and 3 are {\it both}
greater to $W_c$ or {\it both} less than $W_c$. Since the
interpolation is linear, there cannot be a third cut.
More than four edge cuts also implies more than two cuts on a facet.
So, the three possibilities in Figs.3 to 5 are all that remain.
Again, we note that we visit edges 1 to 6 in order, and that
 $t_1$ to $t_4$ "arrive" in order.


\begin{figure}
\vspace*{14cm}
% scaling factor of 1 for dvips is 100, for dvi2ps it is 1.0
\special{psfile=Edge1Edge6.eps hscale=80 vscale=80 hoffset=0 voffset=100}
\caption{Edge 1 and edge 6 are separated}
\end{figure}
\begin{figure}
\vspace*{14cm}
% scaling factor of 1 for dvips is 100, for dvi2ps it is 1.0
\special{psfile=Edge2Edge5.eps hscale=80 vscale=80 hoffset=0 voffset=100}
\caption{Edge 2 and edge 5 are separated}
\end{figure}
\begin{figure}
\vspace*{14cm}
% scaling factor of 1 for dvips is 100, for dvi2ps it is 1.0
\special{psfile=Edge3Edge4.eps hscale=80 vscale=80 hoffset=0 voffset=100}
\caption{Edge 3 and edge 4 are separated}
\end{figure}


\begin{table}
\begin{center}
 \begin{tabular}{|c|c|c|c|}\hline
Edge Pair&    Face   &  $t_a$ &  $t_b$   \\ \hline
1  6 &        1  &   4   &  3    \\ \hline
1  6 &        2  &   1   &  2    \\ \hline
1  6 &        3  &   2   &  4    \\ \hline
1  6 &        4  &   3   &  1    \\ \hline
2  5 &        1  &   4   &  3    \\ \hline
2  5 &        2  &   2   &  4    \\ \hline
2  5 &        3  &   1   &  2    \\ \hline
2  2 &        4  &   3   &  1    \\ \hline
3  4 &        1  &   4   &  3    \\ \hline
3  4 &        2  &   2   &  4    \\ \hline
3  4 &        3  &   3   &  1    \\ \hline
3  4 &        4  &   1   &  2    \\ \hline
\end{tabular}
\end{center}
\caption{The faces cut by nodes $t_1$, $t_2$, $t_3$, and $t_4$ if the
given an edge pair separated by the isosurface.}
\end{table}

So if the first call to $SurfGrow$ has four cut edges, $SurfGrow$
will have to be  called from itself on all four faces with the 
node numbers given in table 2.


Now, on a first call to $SurfGrow$, the tetrahedron number, face numbers
and triangle node numbers are all set negative, and $Done$ is set false.
On arriving in $SurfGrow$, we check if $Done$ is true or not.
If true, we just return -1. Then, if $Done$ is false,
 we set it to be true. Next, if the isosurface  triangle
numbers are
positive, we skip the first call stuff.
The first call just works out the cuts, introduces three new triangle
nodes, and calls $SurfGrow$ on all the neighbouring tetrahedra that must also have 
cut faces.

So, what happens when we arrive in $SurfGrow$ on a recursive call?
When we call $SurfGrow$, we call it passing the neighboring tetrahedron
numbers $in$. Inside the recursive call, this is the current tetrahedron $it$.
We are given the tetrahedron number $it$, the values of $t_a$ and
$t_b$ (internally referred to as $icut1$ and $icut2$. We are also
given the face  $ifacelook$ of $it$ on which these nodes lie. On top of this
we pass the tetrahedral node pair numbers describing the two edge cuts on the face.

There are two possibilities. The tetrahedron $it$ may have one or two
{\it extra} cuts depending on whether it contains a triangular or
a quadrilateral facet. We sum things up in table 3. The first column
is $ifacelook$, the face which is already cut by two nodes $icut1$ and
$icut2$. We have put edge numbers in brackets, and face pairs in parentheses.
The next three columns represent cases where there is only one extra edge cut,
and the next three columns after these represent cases where there are two
extra edge cuts as in Figs.3-5.

We shall write out explicitly the meaning of the row for face 1 having
already been cut by two nodes. There are 6 possibilities. 
Edge 1 may
have a cut, in which case $SurfGrow$ must call itself on neighbours 
 on faces 3 and 4.
Edge 2 may
have a cut, in which case $SurfGrow$ must call itself on neighbours 
 on faces 2 and 4.
Edge 3 may
have a cut, in which case $SurfGrow$ must call itself on neighbours 
 on faces 2 and 3.
Then there are the possibilities that
edge 2 and edge 3 are cut: edge 2 is shared by faces 2 and 4, edge
 3 is shared by faces 2 and 3.
Then it may be that 
edge 1 and edge 3 are cut: edge 1 is shared by faces 4 and 3, edge
 3 is shared by faces 3 and 2.
Lastly it may be that
edge 1 and edge 2 are cut: edge 1 is shared by faces 4 and 3, edge
 2 is shared by faces 3 and 2.



\begin{table}
\begin{center}
 \begin{tabular}{|c|c|c|c|c|c|c|}\hline
face  &edge/faces &          &           &  Fig.3  & Fig.4   & Fig.5   \\ \hline
  1   &      [1] (3,4)   & [2] (2,4)  &   [3] (2,3) & 
 [2](4,2)[3](2,3)  &  [1](4,3)[3](3,2)  & [1](3,4)[2](4,2)   \\ \hline 
  2   &      [1] (3,4)   & [4] (2,4)  &   [5] (1,4) & 
 [5](3,1)[4](1,4)  &  [4](1,4)[1](4,3)  & [5](1,3)[1](3,4)   \\ \hline 
  3   &      [2] (3,4)   & [4] (1,4)  &   [6] (1,2) & 
 [4](1,4)[2](4,2)  &  [6](2,1)[4](1,4)  & [2](4,2)[6](2,1)   \\ \hline 
  4   &      [3] (2,3)   & [5] (1,3)  &   [6] (1,2) &  
 [3](2,3)[5](3,1)  &  [3](3,2)[6](2,1)  & [6](2,1)[5](1,3)   \\ \hline 
\end{tabular}
\end{center}
\caption{
Which edges might be cut given if  $ifacelook$=1,2,3 and 4.}
\end{table}

The reader may prefer a diagram to the last 3 columns of Table.3.
In Fig.6, we summarise Figs.3 to 5. For instance, if face 4 is 
cut by $icut1$ and $icut2$, there may be two further cuts on face
1 on the opposite side of the square. These will be $t_4$ and $t_3$
in our naming convention, and these will be on edges six and 5 of the
tetrahedron. Edge 6 is common to face 2 and face 1, while edge 5 is
common to face 1 and face 2 of the tetrahedron.
\begin{figure}
\vspace*{14cm}
% scaling factor of 1 for dvips is 100, for dvi2ps it is 1.0
\special{psfile=Combine.eps hscale=70 vscale=70 hoffset=-20 voffset=100}
\caption{A summary of Figs.3 to 5. $t_1$ to $t_4$ are marked on the
insides of the squares. The edge numbers are marked outside the corners,
 and the faces shared by an edge are marked on the edges of the squares.}
\end{figure}

\section{So --- What's the Problem?}

Well, there are lots of problems! One big problem is that we are using recursion. Every time $SurfGrow$ calls itself, it places a copy of its current state and data on the function stack. The function stack may grow very deep indeed, and so it can just run out of memory. If this happens it  will just cause the programme to fail with a segmentation fault. At the moment of writing, it has worked on the surfaces I have tried, but on surfaces where there may be a huge amount of facets, it will fail. This problem can be solved (we can define a maximum depth and call $SurfGrow$ in a semi-iterative manner) but for the moment, it can quite simply "blow its stack".

However, there are other problems than this one (most of which have been taken
 care of). We have already  mentioned the obvious problem, the surface may pass
 through the  tetrahedral nodes. In this case there are no tetrahedron edges to cut! The way to get over this problem is by {\it cheating}. What we mean by this is that we just tell $SurfGrow$ that the tetrahedral edges are cut. However, we have to do this in a consistent way. We define a tolerance variable $Tol$ which is always positive, and tells us (within limits) whether a node is to be regarded as actually being on the isosurface.

The simplest case is where just one tetrahedral node is on an isosurface, and there are no cut edges. 
This case is one  we can just ignore altogether. The next simplest case is
 where there are three nodes of the same isosurface. In this we do {\it not} 
move anything, but treat it exactly if we had moved the nodes so that there
 are three cut edges.  For instance, if nodes 2, 3, and 4 are "in the surface"  
 we treated as if we had moved the nodes such that are on the edges between
 node 1 and node 2, node 1 and node 3, and node 1 and node 4. We then set 
the value $Done$ variable of the neighbouring tetrahedron on face 1 to be true.
When two nodes are on the isosurface, things suddenly become a bit complicated.
We give a more detailed account of Surfgrow in the next section.
 
\begin{figure}
\vspace*{14cm}
% scaling factor of 1 for dvips is 100, for dvi2ps it is 1.0
\special{psfile=ThreeNodes.eps hscale=80 vscale=80 hoffset=0 voffset=100}
\caption{Three nodes on the surface are treated as if they are on the edges.}
\end{figure}

\section{ {\it SurfGrow}}

To begin with, the author apologises to anyone who tries to follow the computer code. It is in probably a good example of how $not$ to write a computer program.It may also be a very good example of how $not$ to tackle the problem in general. It just grew and grew in a very ramshackle way. However, we attempt a description here.

One thing that added to the complexity was that it was decided that there should be no repeats of the isosurface triangulation vectors. This in turn demands that need to determine whether a cut on a tetrahedron  edge already exists. To 
do this a function called $GetExists$ was written. We define an array 
$ char tettrinodes[ntet][8]$ keep track of which which edges any
 tetrahedron has cuts on. $GetExists$ returns a negative integer if 
the cut does not already exist. If the cut does already exist, it returns the
identity of a triangle vector. The reason the code is written that way is
because it would be possible to triangle neighbour structure as we did
with a geodesic propagation code for instance. The other thing that adds to
code complexity is the special cases, but these really {\it have} to be dealt
with, otherwise the code might work easily on complicated surfaces but blow 
up given a set of planes.

Note, that on a recursive call, there can be zero, one, or two edge cuts.
Given the integers $ix1,ix2,iy1,iy2$ we can immediately determine which 
 edges are already cut ($iedge1$ and $iedge2$). Then we can set four
of the  $tettrinodes$ values. So, for instance, if edge 6 is the first
cut, then set $tettrinodes[it][0]$ and $tettrinodes[it][1]$ and to be 
nodes 3 and 4 (since edge 6 is between nodes 3 and 4).  
Now the vectors to the triangular grid that is being added is stored
in a C++ vector called $IsoVecs$, and we have a triangle class also.
We make new triangles and store them in another C++ vector called $IsoTris$.
We have two integers $newvecs$ and $newtris$ to keep track of how many we have.
On top of this, we have yet another array $tetcuts$ which tells us which
vectors are cutting it. As comedians are fond of saying "Confused? You soon will be!". Remember, $SurfGrow$ is also passed the ID numbers of two vectors.
So we can also set $tetcuts[it][0]$ and $tetcuts[it][1]$  for the current 
tetrahedron. Having set these for the $GetExists$ function.

So, on a recursive call, we get the four tetrahedron nodes and, if
the tetrahedron's four $w=f(x,y,z)$ values at the nodes mean that it is
cut, we calculate four values $w_1, w_2, w_3$, and $w_4$ that give us
the position vectors of (up to) four points where $w=w_c$. 

We now need four bools, $bed1$ to $bed4$ which tells us which (if any)
 of the four vectors are embedded in the surface. Then six bools
 $bededge1$ to $bededge6$ which tell which (if any) edges are embedded.
We also two integers $corry1$ and $corry2$ (the daft names are from 
"I correspond to icut1"). These will be minus
one unless $icut1$ or $icut2$ are embedded. We need to know that, if
we have an embedded edge, whether that is the calling edge. If
it is the calling edge for example, $corry1$ and $corry2$ are given
the {\it tetrahedron} node numbers that correspond
to the {it triangulation} vector numbers $icut1$ and $icut2$. 
If only one corresponds to $icut1$ or
 $cut2$, then the more integers are set. Two are $cor$ (the single node
that corresponds to one of the calling cuts) and $ec$ is that edge number.
Then $excut$ is the the cut node number that is not embedded, and $ec$ is
the tetrahedron edge number corresponding to that cut. At this point
we can begin various special cases. We shall start off with cases where 
$ncuts$ --- the number of cut edges is zero.

The first special case is where $ncuts$ is zero and 
two tetrahedron nodes are embedded, so there
is an embedded edge, but this edge does {\it not} correspond to $icut1$ and
$icut2$. What has happened here? It has been called with two triangulation
 nodes and only one coincides with tetrahedron node embedded 
in the surface. {\it The way the cuts are calculated excludes any
edges that are in the calling face.  This is why the
routine has found no cuts.} All we have to do set
a new $IsoVec$, and give it the same position as this Tetrahedron
node that coincides exactly with the current isosurface.
At this point, we must realise that calls to $SurfGrow$ {\it
must be made with cut facet edges.} If we get this wrong, $SurfGrow$
 will fail as it calls itself again. A line segment from edge 1
 to edge 6 will blow it!

\begin{figure}
\vspace*{14cm}
% scaling factor of 1 for dvips is 100, for dvi2ps it is 1.0
\special{psfile=NotCallEdge.eps hscale=80 vscale=80 hoffset=0 voffset=100}
\caption{Two embedded nodes, but one is not one of  the calling edge pair.}
\end{figure}

In Fig.7 we depict the situation. One node in black, labeled ic=1
 is one of $icut1$ and $icut2$, say $icut1$. The red node labeled $iF=4$
means that the $ifacecall=4$, other possibilities are that the
call to $SurfGrow$ was with a cut on faces 2 and 3. Now, the
way things have been constructed, if $iF$=4, then the edge
that $icut1$ "is on" is either edge 1 or edge2. The edge
that the new $IsoVec$ has to be set to 5 if $icut1$ is on edge 1,
 or edge 6 if $icut1$ is on edge 2. So, in the last case we set
 $cuts[5]$ to be $true$ (edge 6) and ncuts=1. The new $IsoVec$
will actually be set later. For now we just set $xc6, yc6, zc6$
to be the same as the coordinates for node 5. There is another chunk
of code that sets the triangle's according to the last three new
 triangles. Things have to be fixed so that last three IsoVecs
 arrive in the same order as the cut edges.

If $ncuts=0$ and $ibed=3$ we have another special case. The situation
is as in Fig.6. We know what $ifacelook$ is, and we have worked out what
edges of the current tetrahedron the two calling cuts are on. So for
instance, if the cuts are on edges 4 and 5, the calling
isovecs must be on edge 6 the new cut must be on edge 1 to keep the
 next call to $SurfGrow$ legal. In fact, the situation is similar
when $ibed=1$ and $ncuts=0$.

\begin{figure}
\vspace*{14cm}
% scaling factor of 1 for dvips is 100, for dvi2ps it is 1.0
\special{psfile=RollAround.eps hscale=80 vscale=80 hoffset=0 voffset=100}
\caption{Sometimes there is no triangle to set, we roll around
the calling edge pair.}
\end{figure}


We have a different situation though when we have $ibed=2$, with both
the calling triangulation nodes corresponding to tetrahedral nodes, and
$ncuts=0$. Here there is nowhere to go! In Fig.8 we see why this can occur.
 The black circle represents the calling edge pair (we are looking down a
line segment between them.) What we do here is call $SurfGrow$ from tetrahedron
to tetrahedron with the same calling edge pair. Remember in Fig.7 we had
a pair of lines between nodes 1 and 4. These nodes could either be between
 edges 1 and 5 or edges 2 and 6. This time we imagine the calling
pair to be the red and the black nodes. If ifacelook is two, they
will be on edges 1 and 5. We must now call $SurfGrow$ on the tetrahedron
on face 3, but this time tell it the edge nodes of 2 and 6. Also
we must set $Done$ to be false, or later calls might not be able
 find cut facets and leave holes in the isosurface.

This fixes things till we get to actually setting the triangles. But
if $ibed$ is one we might find that one of the calling triangulation
nodes is corresponds to a tetrahedron node. If this is the case, its
edge number is only a dummy. We need to make sure that we make the
edge legal for later calls. So, after all that, we make two call 
to $GetExists$. This function "rolls around" the edge  that the new
 triangulation node is on. In doing so, it uses $tritetnodes$ and $tetcuts$.
It is called twice in case it hits a mesh boundary in one direction.
Then on top of this, we must handle the special cases when 
$ncuts=2$ and we have a quadrilateral that is to be split into two
triangles.

\section{Afterword}

We know the code is very large and ramshackle. Also, it is 
in danger of blowing its stack. The special case of four embedded 
nodes is not handled. Also, we have not coded up what to do
about periodic boundary conditions. Moreover we have not
put in Gouraud shading, and there is no means for the user to
control the isosurface colours. Another thing is that the screen-shot
function doesn't work with 64 bit machines (you get a blurred
 double image). We hope to find time to improve the code later.

However, we have tested many of the special cases, and the code
now works fine with various surfaces to try and make it get 
things wrong. So far it has proved to be robust, and gives
good results. For presentations, the use of Xvidcap is to be recommended.
This (and gtk-recordmydesktop) can also be used for screen-shots.





\end{document}





